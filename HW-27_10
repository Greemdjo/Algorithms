#include <iostream>
#include <stack>
#include <vector>
#include <algorithm>
using namespace std;

long long orientation(pair<int, int> a, pair<int, int> b, pair<int, int> O) {
    return (long long)(a.first - O.first) * (b.second - O.second)
        - (long long)(a.second - O.second) * (b.first - O.first);
}

long long squared_distance(pair<int, int> a, pair<int, int> b) {
    long long dx = (long long)a.first - b.first;
    long long dy = (long long)a.second - b.second;
    return dx * dx + dy * dy;
}

void SOrted(vector<pair<int, int>>& Coordinate) {
    sort(Coordinate.begin() + 1, Coordinate.end(),
        [&](const auto& a, const auto& b) {
            long long orient = orientation(a, b, Coordinate[0]);
            if (orient != 0) return orient > 0;
            return squared_distance(a, Coordinate[0]) < squared_distance(b, Coordinate[0]);
        });

    int m = 1;
    for (size_t i = 1; i < Coordinate.size(); ++i) {
        while (i < Coordinate.size() - 1 &&
            orientation(Coordinate[i], Coordinate[i + 1], Coordinate[0]) == 0) {
            ++i;
        }
        Coordinate[m++] = Coordinate[i];
    }
    Coordinate.resize(m);
}

void Stack_craft(stack<size_t>& myStack, const vector<pair<int, int>>& Coordinate) {
    if (Coordinate.size() < 2) return;
    myStack.push(0);
    if (Coordinate.size() > 1) myStack.push(1);

    for (size_t i = 2; i < Coordinate.size(); ++i) {
        while (myStack.size() >= 2) {
            size_t top = myStack.top();
            myStack.pop();
            size_t next = myStack.top();
            if (orientation(Coordinate[next], Coordinate[top], Coordinate[i]) > 0) {
                myStack.push(top);
                break;
            }
            
        }
        myStack.push(i);
    }
}

//4
vector<vector<int>> createGraph(int N, int E) {
    vector<vector<int>> graph(N); 

    for (int i = 0; i < E; ++i) {
        int u, v;
        cin >> u >> v; 
        graph[u].push_back(v);  
        graph[v].push_back(u); 
    }

    return graph;
}


int main() {
    //Задача1
    {
        int n;
        cin >> n;

        vector<pair<int, int>> coordinate(n);
        for (int i = 0; i < n; ++i) {
            cin >> coordinate[i].first >> coordinate[i].second;
        }

        size_t min_ind = 0;
        for (size_t i = 1; i < n; ++i) {
            if (coordinate[i].second < coordinate[min_ind].second ||
                (coordinate[i].second == coordinate[min_ind].second &&
                    coordinate[i].first < coordinate[min_ind].first)) {
                min_ind = i;
            }
        }
        swap(coordinate[0], coordinate[min_ind]);
        SOrted(coordinate);
        stack<size_t> myStack;
        Stack_craft(myStack, coordinate);

        vector<size_t> hull;
        while (!myStack.empty()) {
            hull.push_back(myStack.top());
            myStack.pop();
        }
        reverse(hull.begin(), hull.end());

        cout << "Convex Hull:" << endl;
        for (size_t elem : hull) {
            cout << elem << ": " << coordinate[elem].first << " " << coordinate[elem].second << endl;
        }

        // Не в оболочке
        cout << "Not on Hull:" << endl;
        vector<bool> onHull(n, false);
        for (size_t idx : hull) onHull[idx] = true;
        for (size_t i = 0; i < n; i++) {
            if (!onHull[i]) {
                cout << i << ": " << coordinate[i].first << " " << coordinate[i].second << endl;
            }
        }
}

   //Задача4
    /* {
            int N, E;
            cin >> N >> E;  // Ввод N и E

            auto graph = createGraph(N, E);

            // Пример вывода для проверки (опционально)
            for (int i = 0; i < N; ++i) {
                cout << "Вершина " << i << ": ";
                for (int neighbor : graph[i]) {
                    cout << neighbor << " ";
                }
                cout << endl;
            }

            return 0;
       }
*/
}

/*
* Пример к зАдаче1
9
1 -1
3 -1
0 2
3 1
2 2
4 2
3 1
3 3
2 4
*/




























/*Решали на паре
#include <algorithm>
#include <iostream>
#include <vector>
#include <numeric>

using namespace std;

struct box {
	double wi, he;
};

template<typename Iter>
double max_hidden_box(Iter first, Iter last) {

		if (first == last) return 0.0;
		auto it = min_element(first, last, [](auto a, auto b) {return a.he < b.he; });
		double minsq = it->he * accumulate(first, last, 0.0, [](double s, box b)
			{ return s + b.wi; });
		double maxleft = max_hidden_box(first, it);
		double maxright = max_hidden_box(it+1, last);
		return max({ minsq, maxleft, maxright });
}


struct point {
	double x, y;
	point operator-(const point& p) const { return { x - p.x,y - p.y }; };
	double norm2() const { return x * x + y * y; }
	bool operator<(const point& p)
	{
		auto cross = x * p.y - y * p.x;
		return cross > 0 || abs(cross) < 1E-9 && norm2() < p.norm2();
	}
};

pair<vector<int>, vector<int>> convex_Hull(const vector<point>& p)
{
	if (p.size() < 3) return { {0,1}, {} };
	vector<int> idx(p.size());
	iota(begin(idx), end(idx), 0);
	auto it = min_element(begin(idx), end(idx), [&p](auto a, auto b)
		{return p[a].y < p[b].y || p[a].y == p[b].y && p[a].x < p[b].x; });
	sort(begin(idx) + 1, end(idx), [&](auto a, auto b)
		{return p[a] - p[idx[0]] < p[b] - p[idx[0]]; });
	iter_swap(begin(idx), it);
	vector<int> cv{ idx[0], idx[1] }, noncv;
	for (int i = 2; i < p.size(); i++) {
		while (p[idx[i]] - p[cv.back()] < p[cv.back()] - p[cv[cv.back() - 2]]) {
			noncv.push_back(cv.back());
			cv.pop_back();
		}

		cv.push_back(idx[i]);
	}

	return { move(cv), move(noncv) };
}

int main() {
	auto [cv, noncv] = convex_Hull({ {0,2}, {1,1}, {2,2}, {2,0}, {3,3}, {2,4}, {4,3}, {4,5}, {5,4}, {4,1} });
	for (auto p : cv) {
		cout << p << " " << endl;
	}

	for (auto p : noncv) {
		cout << p << " " << endl;
	}


}
*/
